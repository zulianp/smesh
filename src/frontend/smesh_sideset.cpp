#include "smesh_sideset.hpp"
#include "smesh_adjacency.hpp"
#include "smesh_file_extensions.hpp"
#include "smesh_glob.hpp"
#include "smesh_mesh.hpp"
#include "smesh_read.hpp"
#include "smesh_sidesets.hpp"
#include "smesh_tracer.hpp"
#include "smesh_write.hpp"

#include <cstddef>
#include <fstream>
#include <iostream>
#include <list>
#include <vector>

namespace smesh {

class Sideset::Impl final {
public:
  std::shared_ptr<Communicator> comm;
  std::shared_ptr<Buffer<element_idx_t>> parent;
  std::shared_ptr<Buffer<i16>> lfi;
  block_idx_t block_id{0};
};

Sideset::Sideset(const std::shared_ptr<Communicator> &comm,
                 const std::shared_ptr<Buffer<element_idx_t>> &parent,
                 const std::shared_ptr<Buffer<i16>> &lfi, block_idx_t block_id)
    : impl_(std::make_unique<Impl>()) {
  impl_->comm = comm;
  impl_->parent = parent;
  impl_->lfi = lfi;
  impl_->block_id = block_id;
}

Sideset::Sideset() : impl_(std::make_unique<Impl>()) {}
Sideset::~Sideset() = default;

ptrdiff_t Sideset::size() const { return impl_->parent->size(); }

std::shared_ptr<Communicator> Sideset::comm() const { return impl_->comm; }

std::shared_ptr<Sideset>
Sideset::create(const std::shared_ptr<Communicator> &comm,
                const std::shared_ptr<Buffer<element_idx_t>> &parent,
                const std::shared_ptr<Buffer<i16>> &lfi, block_idx_t block_id) {
  return std::make_shared<Sideset>(comm, parent, lfi, block_id);
}

std::shared_ptr<Sideset>
Sideset::create_from_file(const std::shared_ptr<Communicator> &comm,
                          const Path &path, block_idx_t block_id) {
  auto ret = std::make_shared<Sideset>();
  if (ret->read(comm, path, block_id) != SMESH_SUCCESS)
    return nullptr;
  return ret;
}

int Sideset::write(const Path &path) const {
  smesh::create_directory(path.to_string());

  Path parent_path =
      path / ("parent." + std::string(TypeToString<element_idx_t>::value()));
  array_write(parent_path, impl_->parent->data(), impl_->parent->size());

  Path lfi_path = path / ("lfi." + std::string(TypeToString<i16>::value()));
  array_write(lfi_path, impl_->lfi->data(), impl_->lfi->size());

  std::ofstream os((path / "meta.yaml").to_string());

  if (os.good()) {
    os << "# Automatically generated by smesh_Sideset.cpp\n";
    os << "size: " << impl_->parent->size() << "\n";
    os << "parent: parent.raw\n";
    os << "lfi: lfi.int16.raw\n";
    os << "rpath: true\n";
  } else {
    SMESH_ERROR("Unable to open sideset meta.yaml file\n");
    return SMESH_FAILURE;
  }

  os.close();

  return SMESH_SUCCESS;
}

std::vector<std::shared_ptr<Sideset>> Sideset::create_from_selector(
    const std::shared_ptr<Mesh> &mesh,
    const std::function<bool(const geom_t, const geom_t, const geom_t)>
        &selector,
    const std::vector<std::string> &block_names) {
  SMESH_TRACE_SCOPE("Sideset::create_from_selector");

  //   const ptrdiff_t nnodes = mesh->n_nodes();
  const int dim = mesh->spatial_dimension();

  auto points = mesh->points()->data();

  enum ElemType element_type = mesh->element_type();

  const enum ElemType st = side_type(element_type);
  const int nnxs = elem_num_nodes(st);
  const int ns = elem_num_sides(element_type);

  LocalSideTable lst;
  lst.fill(element_type);

  size_t n_blocks = mesh->n_blocks();
  std::vector<std::shared_ptr<Sideset>> sidesets;

  for (size_t b = 0; b < n_blocks; b++) {
    auto block = mesh->block(b);
    if (!block_names.empty() && //
        std::find(block_names.begin(), block_names.end(), block->name()) ==
            block_names.end()) {
      continue;
    }

    const ptrdiff_t nelements = block->n_elements();
    auto elements = block->elements()->data();

    std::list<element_idx_t> parent_list;
    std::list<i16> lfi_list;
    for (ptrdiff_t e = 0; e < nelements; e++) {
      for (int s = 0; s < ns; s++) {
        // Barycenter of face
        double p[3] = {0, 0, 0};

        for (int ln = 0; ln < nnxs; ln++) {
          const idx_t node = elements[lst(s, ln)][e];

          for (int d = 0; d < dim; d++) {
            p[d] += points[d][node];
          }
        }

        for (int d = 0; d < dim; d++) {
          p[d] /= nnxs;
        }

        if (selector(p[0], p[1], p[2])) {
          parent_list.push_back(e);
          lfi_list.push_back(s);
        }
      }
    }

    const ptrdiff_t nparents = parent_list.size();
    auto parent = create_host_buffer<element_idx_t>(nparents);
    auto lfi = create_host_buffer<i16>(nparents);

    {
      ptrdiff_t idx = 0;
      for (auto p : parent_list) {
        parent->data()[idx++] = p;
      }
    }

    {
      ptrdiff_t idx = 0;
      for (auto l : lfi_list) {
        lfi->data()[idx++] = l;
      }
    }

    sidesets.push_back(std::make_shared<Sideset>(mesh->comm(), parent, lfi, b));
  }

  return sidesets;
}

int Sideset::read(const std::shared_ptr<Communicator> &comm, const Path &folder,
                  block_idx_t block_id) {
  SMESH_TRACE_SCOPE("Sideset::read");
  if (comm->size() > 1) {
    SMESH_ERROR("Sideset::read is not supported for distributed runs\n");
    return SMESH_FAILURE;
  }

  impl_->comm = comm;
  ptrdiff_t nlocal{0}, ncheck{0};
  element_idx_t *parent{nullptr};
  i16 *lfi{nullptr};

  auto parent_file =
      detect_files(folder / "parent", {".raw", ".int16", ".int32", ".int64"});
  auto lfi_file =
      detect_files(folder / "lfi", {".raw", ".int16", ".int32", ".int64"});

  if (parent_file.empty() || lfi_file.empty()) {
    SMESH_ERROR("Unable to find parent or lfi file in sideset at %s\n",
                folder.c_str());
    return SMESH_FAILURE;
  }

  int ret = SMESH_SUCCESS;
  ret |= array_read_convert_from_extension(parent_file[0], &parent, &nlocal);
  ret |= array_read_convert_from_extension(lfi_file[0], &lfi, &ncheck);

  impl_->parent = smesh::manage_host_buffer(nlocal, parent);
  impl_->lfi = smesh::manage_host_buffer(nlocal, lfi);

  if (ncheck != nlocal) {
    SMESH_ERROR("Inconsistent array sizes in sideset at %s\n", folder.c_str());
    ret = SMESH_FAILURE;
  }

  impl_->block_id = block_id;
  return ret;
}

std::shared_ptr<Buffer<element_idx_t>> Sideset::parent() {
  return impl_->parent;
}
std::shared_ptr<Buffer<i16>> Sideset::lfi() { return impl_->lfi; }
block_idx_t Sideset::block_id() const { return impl_->block_id; }

std::shared_ptr<Buffer<idx_t>> create_nodeset_from_sidesets(
    const std::shared_ptr<Mesh> &mesh,
    const std::vector<std::shared_ptr<Sideset>> &sidesets) {
  if (sidesets.empty()) {
    return nullptr;
  }

  if (sidesets.size() == 1) {
    return create_nodeset_from_sideset(mesh, sidesets[0]);
  }

  block_idx_t n_sidesets = sidesets.size();
  std::vector<enum ElemType> element_type(n_sidesets);
  std::vector<idx_t **> elems(n_sidesets);
  std::vector<ptrdiff_t> n_surf_elements(n_sidesets);
  std::vector<element_idx_t *> parent_element(n_sidesets);
  std::vector<i16 *> side_idx(n_sidesets);

  for (block_idx_t k = 0; k < n_sidesets; k++) {
    auto ss = sidesets[k];
    auto block = mesh->block(ss->block_id());

    element_type[k] = block->element_type();
    elems[k] = block->elements()->data();
    n_surf_elements[k] = ss->parent()->size();
    parent_element[k] = ss->parent()->data();
    side_idx[k] = ss->lfi()->data();
  }

  ptrdiff_t n_nodes_out{0};
  idx_t *nodes_out{nullptr};

  extract_nodeset_from_sidesets(n_sidesets, element_type.data(), elems.data(),
                                n_surf_elements.data(), parent_element.data(),
                                side_idx.data(), &n_nodes_out, &nodes_out);

  return smesh::manage_host_buffer(n_nodes_out, nodes_out);
}

// std::shared_ptr<Buffer<idx_t>>
// create_nodeset_from_sideset(const std::shared_ptr<Mesh> &mesh,
//                             const std::shared_ptr<Sideset> &sideset) {

// ptrdiff_t n_nodes{0};
// idx_t *nodes{nullptr};
//   if (extract_nodeset_from_sideset(
//           mesh->element_type(), mesh->elements()->data(),
//           sideset->parent()->size(), sideset->parent()->data(),
//           sideset->lfi()->data(), &n_nodes, &nodes) != SMESH_SUCCESS) {
//     SMESH_ERROR("Unable to extract nodeset from sideset!\n");
//   }

//   return smesh::manage_host_buffer(n_nodes, nodes);
// }

std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>>
create_surface_from_sideset(const std::shared_ptr<Mesh> &mesh,
                            const std::shared_ptr<Sideset> &sideset) {

  auto st = shell_type(side_type(mesh->element_type()));
  int nnxs = elem_num_nodes(st);

  auto surface =
      smesh::create_host_buffer<idx_t>(nnxs, sideset->parent()->size());

  if (extract_surface_from_sideset(
          mesh->element_type(), mesh->elements()->data(),
          sideset->parent()->size(), sideset->parent()->data(),
          sideset->lfi()->data(), surface->data()) != SMESH_SUCCESS) {
    SMESH_ERROR("Unable to create surface from sideset!");
  }
  return {st, surface};
}

std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>>
create_surface_from_sidesets(
    const std::shared_ptr<Mesh> &mesh,
    const std::vector<std::shared_ptr<Sideset>> &sidesets) {
  if (sidesets.empty()) {
    return {INVALID, nullptr};
  }

  if (sidesets.size() == 1) {
    return create_surface_from_sideset(mesh, sidesets[0]);
  }

  SMESH_ERROR("IMPLEMENT ME\n");
  return {INVALID, nullptr};
}

// SemiStructuredMesh version

std::shared_ptr<Buffer<idx_t>>
create_nodeset_from_sideset(const std::shared_ptr<SemiStructuredMesh> &ss,
                            const std::shared_ptr<Sideset> &sideset) {
  ptrdiff_t n_nodes{0};
  idx_t *nodes{nullptr};

  SMESH_TRACE_SCOPE("sshex8_extract_nodeset_from_sideset");
  if (sshex8_extract_nodeset_from_sideset(
          ss->level(), ss->element_data(), sideset->parent()->size(),
          sideset->parent()->data(), sideset->lfi()->data(), &n_nodes,
          &nodes) != SMESH_SUCCESS) {
    SMESH_ERROR("Unable to extract nodeset from sideset!\n");
  }

  return smesh::manage_host_buffer(n_nodes, nodes);
}

std::shared_ptr<Buffer<idx_t>>
create_nodeset_from_sideset(const std::shared_ptr<Mesh> &mesh,
                            const std::shared_ptr<Sideset> &sideset) {

  ptrdiff_t n_nodes{0};
  idx_t *nodes{nullptr};
  if (extract_nodeset_from_sideset(
          mesh->element_type(), mesh->elements()->data(),
          sideset->parent()->size(), sideset->parent()->data(),
          sideset->lfi()->data(), &n_nodes, &nodes) != SMESH_SUCCESS) {
    SMESH_ERROR("Unable to extract nodeset from sideset!\n");
  }

  return smesh::manage_host_buffer(n_nodes, nodes);
}

std::pair<enum ElemType, std::shared_ptr<Buffer<idx_t *>>>
create_surface_from_sideset(const std::shared_ptr<SemiStructuredMesh> &ssmesh,
                            const std::shared_ptr<Sideset> &sideset) {

  auto ss_sides = smesh::create_host_buffer<idx_t>(
      (ssmesh->level() + 1) * (ssmesh->level() + 1), sideset->parent()->size());

  if (sshex8_extract_surface_from_sideset(
          ssmesh->level(), ssmesh->element_data(), sideset->parent()->size(),
          sideset->parent()->data(), sideset->lfi()->data(),
          ss_sides->data()) != SMESH_SUCCESS) {
    SMESH_ERROR("Unable to extract surface from sideset!\n");
  }

  //   idx_t *idx = nullptr;
  //   ptrdiff_t n_contiguous = invalid_idx<ptrdiff_t>();
  std::vector<int> levels(sshex8_hierarchical_n_levels(ssmesh->level()));

  // FiXME harcoded for sshex8
  sshex8_hierarchical_mesh_levels(ssmesh->level(), levels.size(),
                                  levels.data());

  const int nnxs = 4;
  const int nexs = ssmesh->level() * ssmesh->level();
  auto surface =
      smesh::create_host_buffer<idx_t>(nnxs, sideset->parent()->size() * nexs);

  ssquad4_to_standard_quad4_mesh(ssmesh->level(), sideset->parent()->size(),
                                 ss_sides->data(), surface->data());
  return {QUADSHELL4, surface};
}

} // namespace smesh
